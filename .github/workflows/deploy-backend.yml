name: Deploy Backend (Elastic Beanstalk)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

concurrency:
  group: deploy-backend
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ap-south-1
      AWS_DEFAULT_REGION: ap-south-1
      APP_NAME: studentpilot-backend
      ENV_NAME: WheresMyStipend-env-1
      PORT: 8000
      WORKING_DIR: .
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install EB CLI
        run: |
          pip install --upgrade pip
          pip install awsebcli

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-south-1

      - name: Debug region/keys presence
        run: |
          echo "AWS_REGION=$AWS_REGION"
          echo "AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION"
          test -n "$AWS_ACCESS_KEY_ID" && echo "Access key present" || echo "Access key MISSING"
          test -n "$AWS_SECRET_ACCESS_KEY" && echo "Secret key present" || echo "Secret key MISSING"

      - name: Verify AWS identity
        run: |
          pip install awscli --quiet
          aws sts get-caller-identity

      - name: Ensure EB app/env (root Dockerfile)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set -e
          # If previous config exists inside backend/ migrate it
          if [ ! -d .elasticbeanstalk ] && [ -d backend/.elasticbeanstalk ]; then
            echo "Migrating existing EB config from backend/.elasticbeanstalk to root";
            cp -R backend/.elasticbeanstalk .
          fi
          if [ ! -d .elasticbeanstalk ]; then
            eb init $APP_NAME --region $AWS_REGION --platform Docker
          fi
          # Robust existence check using eb status (fast) – if fails, we'll attempt create
          if eb status $ENV_NAME >/dev/null 2>&1; then
            echo "Environment '$ENV_NAME' already exists (eb status ok)."
          else
            echo "Environment '$ENV_NAME' not detected via eb status; attempting create..."
            set +e
            CREATE_OUT=$(eb create $ENV_NAME --single --timeout 20 2>&1)
            CREATE_CODE=$?
            set -e
            echo "$CREATE_OUT"
            if [ $CREATE_CODE -ne 0 ]; then
              if echo "$CREATE_OUT" | grep -qi 'already exists'; then
                echo "Create reported 'already exists' – treating as success."
              else
                echo "Environment create failed (unexpected)." >&2
                exit 1
              fi
            fi
          fi
          # Associate local config; ignore failures
            eb use $ENV_NAME || echo "Warning: eb use failed (continuing)."

      - name: Set env vars (backend)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          eb setenv PORT=8000 DISABLE_LINKEDIN=1 || true

      - name: Deploy (race-free version processing wait)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set -e
          SHORT_SHA=${GITHUB_SHA::7}
          LABEL=Auto-${GITHUB_RUN_NUMBER}-${SHORT_SHA}
          echo "Creating application version $LABEL (separate from environment update)"
          # Create / Upload application version only (without immediate environment update) using eb deploy with --label but suppressing env update by using --nohang and aborting after upload detection.
          # The EB CLI doesn't provide a direct 'create-app-version' stable command, so we let first failure trigger version registration wait if race.
          set +e
          OUTPUT=$(eb deploy $ENV_NAME --staged --label $LABEL 2>&1)
          CODE=$?
          set -e
          echo "$OUTPUT"
          if [ $CODE -ne 0 ] && echo "$OUTPUT" | grep -qi 'No Application Version named'; then
            echo "Detected early environment update attempt before version processed. Proceeding to explicit wait for version registration + processing."
          elif [ $CODE -eq 0 ]; then
            echo "eb deploy fully succeeded; skipping manual wait."
            exit 0
          else
            echo "eb deploy failed with unexpected error." >&2
            exit $CODE
          fi
          echo "Waiting for application version '$LABEL' to register..."
          for i in $(seq 1 24); do
            COUNT=$(aws elasticbeanstalk describe-application-versions --application-name "$APP_NAME" --version-labels "$LABEL" --query 'ApplicationVersions | length(@)')
            if [ "$COUNT" != "0" ]; then
              STATUS=$(aws elasticbeanstalk describe-application-versions --application-name "$APP_NAME" --version-labels "$LABEL" --query 'ApplicationVersions[0].Status' --output text)
              echo "  Found version (status=$STATUS)"
              if [ "$STATUS" = "PROCESSED" ]; then
                echo "Version processed. Updating environment now."
                aws elasticbeanstalk update-environment --environment-name "$ENV_NAME" --version-label "$LABEL"
                break
              fi
            else
              echo "  Not yet visible (attempt $i)"
            fi
            sleep 5
          done
          # Final confirmation
          FINAL_STATUS=$(aws elasticbeanstalk describe-application-versions --application-name "$APP_NAME" --version-labels "$LABEL" --query 'ApplicationVersions[0].Status' --output text || echo MISSING)
          if [ "$FINAL_STATUS" != "PROCESSED" ]; then
            echo "Application version did not reach PROCESSED state (status=$FINAL_STATUS)." >&2
            exit 1
          fi
          echo "Environment update initiated with version $LABEL."

      - name: Show status
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          eb status $ENV_NAME || true
          eb health $ENV_NAME --refresh || true

      - name: Output CNAME
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          eb status $ENV_NAME | grep CNAME || true

      - name: Smoke test (health & sample search)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set -e
          CNAME=$(eb status $ENV_NAME | awk '/CNAME:/ {print $2}')
          if [ -z "$CNAME" ]; then echo "Could not determine CNAME"; exit 1; fi
          ORIGIN=https://$CNAME
          echo "CNAME=$CNAME" | tee cname.txt
          echo "Health:" && curl -fsS $ORIGIN/health || (echo "Health check failed" && exit 1)
          echo "Sample search:" && curl -s -X POST "$ORIGIN/api/search" -H 'Content-Type: application/json' \
            -d '{"query":"software","location":"","mode":"","min_stipend":0,"skills":[],"domains":[]}' | head -c 400 || true
          echo "Done." 

      - name: Upload CNAME artifact
        uses: actions/upload-artifact@v4
        with:
          name: eb-cname
          path: backend/cname.txt
