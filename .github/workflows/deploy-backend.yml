name: Deploy Backend (Elastic Beanstalk)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

concurrency:
  group: deploy-backend
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ap-south-1
      AWS_DEFAULT_REGION: ap-south-1
      APP_NAME: studentpilot-backend
      ENV_NAME: WheresMyStipend-env-1
      PORT: 8000
      WORKING_DIR: .
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install EB CLI
        run: |
          pip install --upgrade pip
          pip install awsebcli

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-south-1

      - name: Debug region/keys presence
        run: |
          echo "AWS_REGION=$AWS_REGION"
          echo "AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION"
          test -n "$AWS_ACCESS_KEY_ID" && echo "Access key present" || echo "Access key MISSING"
          test -n "$AWS_SECRET_ACCESS_KEY" && echo "Secret key present" || echo "Secret key MISSING"

      - name: Verify AWS identity
        run: |
          pip install awscli --quiet
          aws sts get-caller-identity

      - name: Ensure EB app/env (root Dockerfile)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set -e
          # If previous config exists inside backend/ migrate it
          if [ ! -d .elasticbeanstalk ] && [ -d backend/.elasticbeanstalk ]; then
            echo "Migrating existing EB config from backend/.elasticbeanstalk to root";
            cp -R backend/.elasticbeanstalk .
          fi
          if [ ! -d .elasticbeanstalk ]; then
            eb init $APP_NAME --region $AWS_REGION --platform Docker
          fi
          # Robust existence check using eb status (fast) – if fails, we'll attempt create
          if eb status $ENV_NAME >/dev/null 2>&1; then
            echo "Environment '$ENV_NAME' already exists (eb status ok)."
          else
            echo "Environment '$ENV_NAME' not detected via eb status; attempting create..."
            set +e
            CREATE_OUT=$(eb create $ENV_NAME --single --timeout 20 2>&1)
            CREATE_CODE=$?
            set -e
            echo "$CREATE_OUT"
            if [ $CREATE_CODE -ne 0 ]; then
              if echo "$CREATE_OUT" | grep -qi 'already exists'; then
                echo "Create reported 'already exists' – treating as success."
              else
                echo "Environment create failed (unexpected)." >&2
                exit 1
              fi
            fi
          fi
          # Associate local config; ignore failures
            eb use $ENV_NAME || echo "Warning: eb use failed (continuing)."

      - name: Set env vars (backend)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          eb setenv PORT=8000 DISABLE_LINKEDIN=1 || true

      - name: Deploy (with retry if version race)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set -e
          SHORT_SHA=${GITHUB_SHA::7}
          LABEL=Auto-${GITHUB_RUN_NUMBER}-${SHORT_SHA}
          echo "Deploying label $LABEL from root (Dockerfile at repository root)"
          set +e
          OUTPUT=$(eb deploy $ENV_NAME --staged --label $LABEL 2>&1)
          CODE=$?
          echo "$OUTPUT"
          if [ $CODE -ne 0 ] && echo "$OUTPUT" | grep -qi 'No Application Version named'; then
            echo "Encountered version lookup race. Waiting 15s and retrying..."
            sleep 15
            OUTPUT2=$(eb deploy $ENV_NAME --staged --label $LABEL 2>&1)
            CODE=$?
            echo "$OUTPUT2"
          fi
          set -e
          if [ $CODE -ne 0 ]; then
            echo "Deploy failed after retry." >&2
            exit $CODE
          fi

      - name: Show status
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          eb status $ENV_NAME || true
          eb health $ENV_NAME --refresh || true

      - name: Output CNAME
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          eb status $ENV_NAME | grep CNAME || true

      - name: Smoke test (health & sample search)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set -e
          CNAME=$(eb status $ENV_NAME | awk '/CNAME:/ {print $2}')
          if [ -z "$CNAME" ]; then echo "Could not determine CNAME"; exit 1; fi
          ORIGIN=https://$CNAME
          echo "CNAME=$CNAME" | tee cname.txt
          echo "Health:" && curl -fsS $ORIGIN/health || (echo "Health check failed" && exit 1)
          echo "Sample search:" && curl -s -X POST "$ORIGIN/api/search" -H 'Content-Type: application/json' \
            -d '{"query":"software","location":"","mode":"","min_stipend":0,"skills":[],"domains":[]}' | head -c 400 || true
          echo "Done." 

      - name: Upload CNAME artifact
        uses: actions/upload-artifact@v4
        with:
          name: eb-cname
          path: backend/cname.txt
